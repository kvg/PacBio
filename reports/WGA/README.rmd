Lowering the barrier to entry for long-read sequencing with whole-genome amplification
==

Long-read sequencing can produce very long genomic fragments with an N50 of ~10-20 kb, with some fragments as long as ~50 kb.  However, they typically require a large amount of high molecular weight DNA (5 to 15 ug), limiting their applications.  Particular to malaria parasite sequencing, culturing a sufficient number of *Plasmodium falciparum* parasites to obtain the desired gDNA yield is enormously difficult and time-consuming.  Alternatively, one can consider whole-genome amplification on a small amount of DNA - say ~1 ng - to the requisite 15 ug level.  Standard WGA kits employing the Taq polymerase are inappropriate for such a task; Taq-produced amplicons are typically up to 3 or 4 kb, negating much of the value of long-read sequencing.  Instead, multiple displacement amplification (MDA) employs Phi-29, a polymerase with much higher replication fidelity and capability to generate amplicons greater than 20 kb in length.

We explored the use of MDA-based WGA to produce a draft-quality genome assembly of a malaria parasite genome.  Specifically, we amplified 1 ng of 3D7 to 15 ug and performed PacBio sequencing on the resulting amplicons.

```{r setup, echo=FALSE}
library("seqinr");

n50 <- function(f) {
    lengths = sort(as.vector(unlist(lapply(f, function(x) { return(length(x)) }))));

    totalLength = sum(lengths);

    n50Length = 0;
    n50Value = 0;
    for (length in lengths) {
        n50Length = n50Length + length;
        n50Value = length;

        if (n50Length >= totalLength/2) {
            break;
        }
    }

    return(n50Value);
}

ng50 <- function(f, r) {
    lengths = sort(as.vector(unlist(lapply(f, function(x) { return(length(x)) }))));
    lengths.ref = sort(as.vector(unlist(lapply(r, function(x) { return(length(x)) }))));

    totalLength = sum(lengths.ref);

    n50Length = 0;
    n50Value = 0;
    for (length in lengths) {
        n50Length = n50Length + length;
        n50Value = length;

        if (n50Length >= totalLength/2) {
            break;
        }
    }

    return(n50Value);
}

results.dir = "../../results/wga";
data.dir = "../../data";
resources.dir = "../../resources";
```

```{r lengthDist, echo=FALSE}
lengthDists = read.table(paste(results.dir, "lengths.dist.txt", sep="/"), header=TRUE, stringsAsFactors=FALSE);

colors.cshl = c("#0B7CFB", "#085DBB", "#05376F", "#063D7C", "#042A55");
colors.cshl.index = 1;
colors.pb   = c("#3B000E", "#480012", "#D40034", "#880021", "#950024", "#6E001B", "#7B001E", "#AE002A");
colors.pb.index = 1;

plot(0, 0, type="n", xlim=c(0, nrow(lengthDists)), ylim=c(0, max(lengthDists[,2:ncol(lengthDists)])), bty="n", xlab="Length (bp)", ylab="Count", cex=1.3, cex.lab=1.3, cex.axis=1.3);

legend.names = c();
legend.colors = c();

for (i in 2:ncol(lengthDists)) {
    lengthDist = lengthDists[, c(1, i)];
    name = names(lengthDists)[i];

    color = "red";
    if (grepl("PacBio", name)) {
        color = colors.pb[colors.pb.index];
        colors.pb.index = colors.pb.index + 1;
    } else if (grepl("CSHL", name)) {
        color = colors.cshl[colors.cshl.index];
        colors.cshl.index = colors.cshl.index + 1;
    }

    cat(name, " ", color, "\n");

    legend.names = c(legend.names, name);
    legend.colors = c(legend.colors, color);

    indices = which(lengthDists[,i] != 0);
    points(lengthDists$length[indices], lengthDists[indices, i], type="l", lwd=1, col=color);
}

legend.order = order(legend.names);
legend("topright", legend.names[legend.order], col=legend.colors[legend.order], lwd=3, bty="n");
```

```{r lengthStats, echo=FALSE, results='asis'}
lengthStats = read.table(paste(results.dir, "lengths.stats.txt", sep="/"), header=TRUE, stringsAsFactors=FALSE);
lengthStats$n50Length = NULL;

lengthStats.order = order(lengthStats$key);
kable(lengthStats[lengthStats.order,], row.names=FALSE);
```

```{r loadFastas, echo=FALSE, cache=TRUE}
ref = "../../resources/references/3D7/PlasmoDB-9.0_Pfalciparum3D7_Genome.sorted.fasta";

f.ref   = read.fasta(ref);
f.unamp = read.fasta(paste(data.dir, "ASMTest1.polished_assembly.fasta", sep="/"));
f.amp   = read.fasta(paste(data.dir, "WGATest5.polished_assembly.fasta", sep="/"));
```

```{r loadCoverage, echo=FALSE, cache=TRUE}
cov = read.table(paste(results.dir, "coverage.simple.txt", sep="/"), header=FALSE, stringsAsFactors=FALSE);
names(cov) = c("chrom", "start", "amplified", "unamplified");
```

```{r showCoverageOverIdeogram, echo=FALSE, fig.height=6, fig.width=12, dpi=300, cache=TRUE}
chroms.length = lapply(f.ref, function(x) { return(length(x)); });
chroms = names(chroms.length);

mask = read.table(paste(resources.dir, "/tbl_telomere.txt", sep=""), header=TRUE, stringsAsFactors=FALSE);
access = read.table(paste(resources.dir, "/regions-20130225.txt", sep=""), header=FALSE, stringsAsFactors=FALSE);
names(access) = c("chrom", "start", "stop", "type");
access = subset(access, type != "Core");

par(mar=c(5, 11, 2, 1));

color.amp = "red";
color.unamp = "blue";

plot(0, 0, type="n", xlim=c(0, max(unlist(chroms.length)) + 500000), ylim=c(-2, length(chroms.length) + 1), bty="n", xlab="Length (bp)", ylab="", yaxt="n", cex=1.3, cex.axis=1.3, cex.lab=1.3);

for (chr in chroms) {
    pos = as.integer(gsub("_v3", "", gsub("Pf3D7_", "", chr)));
    if (chr == "PFC10_API_IRAB") { pos = 0; }
    else if (chr == "M76611") { pos = -1; }

    chrlength = chroms.length[[chr]];

    mtext(chr, side=2, at=pos, las=1, cex=1.3);

    submask = subset(mask, chrom == chr);
    if (nrow(submask) > 0) {
        rect(submask$co_pos_min, pos - 0.1, submask$co_pos_max, pos + 0.1, col="gray", border=NA);
    }

    acc = subset(access, chrom == chr);
    if (nrow(acc) > 0) {
        rect(acc$start, pos - 0.1, acc$stop, pos + 0.1, col="red", border=NA);
    }

    rect(0, pos - 0.1, chrlength, pos + 0.1);

    cov.chr = subset(cov, chrom == chr);
    cov.start = cov.chr$start;

    amp.max = max(cov.chr$amplified);
    unamp.max = max(cov.chr$unamplified);

    window = 2000;
    interval = seq(1, length(cov.start), by=window);

    amp.mincov = c();
    unamp.mincov = c();
    for (i in interval) {
        amp.mincov = c(amp.mincov, min(cov.chr$amplified[i:(i+window)]));
        unamp.mincov = c(unamp.mincov, min(cov.chr$unamplified[i:(i+window)]));
    }

    points(cov.start[interval], pos + 0.1 +  0.3*(amp.mincov / max(amp.mincov, na.rm=TRUE)), type="l", col=color.amp, lwd=0.5);
    points(cov.start[interval], pos - 0.1 + -0.3*(unamp.mincov / max(unamp.mincov, na.rm=TRUE)), type="l", col=color.unamp, lwd=0.5);
}

legend("bottomright", c("Coverage from amplified DNA", "Coverage from unamplified DNA"), col=c(color.amp, color.unamp), lwd=2, bty="n");
```

```{r asmStats, echo=FALSE, results='asis'}
asmStats = read.table(paste(results.dir, "assembly.stats", sep="/"), header=TRUE);

kable(asmStats[order(asmStats$numContigs), c("id", "numContigs", "minLength", "maxLength", "n50", "ng50", "totalSequence")], row.names=FALSE);
```

```{r dotPlots, echo=FALSE, results='asis', cache=TRUE}
dotplot.unamp.ps  = paste(results.dir, "mummer/3D7.unamplified.filter.ps", sep="/");
dotplot.unamp.png = paste("figure/3D7.unamplified.filter.png", sep="/");
system(paste("../../bin/convert -density 300 -rotate 90", dotplot.unamp.ps, dotplot.unamp.png));

dotplot.amp.ps  = paste(results.dir, "mummer/3D7.amplified.filter.ps", sep="/");
dotplot.amp.png = paste("figure/3D7.amplified.filter.png", sep="/");
system(paste("../../bin/convert -density 300 -rotate 90", dotplot.amp.ps, dotplot.amp.png));

cat("![dotplot_unamp](", dotplot.unamp.png, ")\n");
cat("![dotplot_amp](", dotplot.amp.png, ")\n");
```

```{r alignments, echo=FALSE, results='asis', eval=FALSE}
coord_summary = read.table(paste(results.dir, "mummer/3D7.amplified.filter.filter.coord_summary", sep="/"), header=FALSE, stringsAsFactors=FALSE);
names(coord_summary) = c( "S1", "E1", "S2", "E2", "LEN_1", "LEN_2", "LEN_R", "LEN_Q", "COV_R", "COV_Q", "CHROM", "CONTIG" );

alignment.frame = data.frame(row.names = names(f.amp));

for (contig in names(f.amp)) {
    alignment.frame[contig, "length"] = length(f.amp[[contig]]);
    alignment.frame[contig, "chroms"] = paste(unique(subset(coord_summary, CONTIG == contig)$CHROM), collapse=", ");
}
```

```{r variantReport, echo=FALSE, results='asis'}
fields = c( "TotalSeqs", "AlignedSeqs", "UnalignedSeqs", "TotalBases", "AlignedBases", "UnalignedBases", "Breakpoints", "Relocations", "Translocations", "Inversions", "Insertions", "InsertionSum", "InsertionAvg", "TandemIns", "TandemInsSum", "TandemInsAvg", "TotalSNPs", "AT", "AC", "AG", "TA", "TC", "TG", "CA", "CT", "CG", "GA", "GT", "GC", "TotalIndels", "A.", "T.", "C.", "G.", ".A", ".T", ".C", ".G" );

variantReport = data.frame(1:length(fields), row.names=fields);
variantReport$unamp_ref = NA;
variantReport$unamplified = NA;
variantReport$amp_ref = NA;
variantReport$amplified = NA;
variantReport$X1.length.fields. = NULL;

unamp.lines = readLines(paste(results.dir, "mummer/3D7.unamplified.report", sep="/"));
for (l in unamp.lines) {
    values = unlist(strsplit(l, "\\s+"));
    field = values[1];

    if (field %in% fields && is.na(variantReport[field, "unamplified"])) {
        variantReport[field, "unamp_ref"] = values[2];
        variantReport[field, "unamplified"] = values[3];
    }
}

amp.lines = readLines(paste(results.dir, "mummer/3D7.amplified.report", sep="/"));
for (l in amp.lines) {
    values = unlist(strsplit(l, "\\s+"));
    field = values[1];

    if (field %in% fields && is.na(variantReport[field, "amplified"])) {
        variantReport[field, "amp_ref"] = values[2];
        variantReport[field, "amplified"] = values[3];
    }
}

for (field in fields) {
    if (field != "TotalSeqs" && field != "TotalBases") {
        #variantReport[field, "unamp_ref"] = "NA";
        #variantReport[field, "amp_ref"] = "NA";
    }
}
```

```{r scaffoldLengths, echo=FALSE}
#f.ref.size = sum(unlist(lapply(f.ref, function(x) { return(length(x)) })));

#plot(ecdf(as.vector(sort(unlist(lapply(f.amp, function(x) { return(length(x)) }))))))
#plot(ecdf(as.vector(sort(unlist(lapply(f.unamp, function(x) { return(length(x)) }))))))
```

